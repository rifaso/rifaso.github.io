---
layout: post
title: 'Project Euler - Problem 2'
date: 2015-07-17 22:50:08
categories: project-euler
comments: true
---
# Problem 2 - Even Fibonacci numbers 

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 
## How I Solved It

First I would like to state that the Fibonacci sequence provided in the question is slightly different than the sequence is usually given - either 1, 1, 2, 3, 5, etc or 0, 1, 1, 2, 3, 5, etc. Though this should not effect the final answer as in the end we only care about the sum of the even sequences below four million, it may affect my intermediate answers.

Getting started I wanted to be able to solve for each term. I started with Term 1 which equals 1.

```ruby 
def term
  1
end
```

Then moved on to Term 2 and 3 which equal 2 and 3 respectively. 

```ruby 
def term(number)
  number
end
```

Then to term 4 whicn equals 5.

```ruby 
def term(number)
  number <=3 ? number : 5
end
```

Then term 5 which equals 8. I know that I could solve this with recursion but knowing that there is a formula to find the result of any given term, I decided to use that instead.

```ruby
GOLDENMEAN = (1+Math.sqrt(5)).fdiv(2)
PHI = (1-Math.sqrt(5)).fdiv(2)

def term(number)
  number = number + 1
  (GOLDENMEAN**number - (PHI)**number).fdiv(Math.sqrt(5)).round
end
```

The equation as is assumes that the Fibonacci Sequence is 1, 1, 2, 3, 5, etc. To adjust I had to add 1 to number. Also, the `#round` method was required due to the fact that I was having problems with floating point.  

Next I wanted to test that I could get the sequence of terms.

```ruby
  def sequence(number)
    seq = []
    (1..number).each do |number|
      seq << term(number)
    end
    seq
  end
```

To then find the sequences less than a number I did the following.

```ruby
  def sequence_less_than(max_number)
    seq = []
    (1..max_number).each do |number|
      seq << term(number)
      if term(number) >= max_number
        seq.pop
        return @seq
      end
    end
  end
```

You'll notice this is very similar to sequence. I'm initially passing in all the numbers from 1 to the "max_number" to solve for each term. However this isn't really what I want to do. What I want to do is only list solutions untill I reach that max number. To address that, I've added that we should end the each block if a solution is greater than our max number. This does have the consequence that that a number that is greater than the max number has been already added to the array so it needs to be removed with `pop` before the array is returned. I'm not the happiest with this method but it does what I need. I will be looking at it again later to see if I can come up with something better.

I then filtered for even numbered solutions only but to do this I had to turn my local variable into an instance variable. 

```ruby
  def sequence_less_than(max_number)
    @seq = []
    (1..max_number).each do |number|
      @seq << term(number)
      if term(number) >= max_number
        @seq.pop
        return @seq
      end
    end
  end

  def even_sequence_less_than(max_number)
    sequence_less_than(max_number)
    @seq.delete_if {|number| number.odd?}
  end
```

Last, I wrote a method that would sum those values.

```ruby
  def sum_of_even_sequence_less_than(max_number)
    even_sequence_less_than(max_number).reduce (:+)
  end
```

What do you think? Any comments or suggestions are welcome.

All of my code and tests for this question can be found at this [GitHub repo][gh-pe].

[gh-pe]:https://github.com/mlongerich/project_euler
